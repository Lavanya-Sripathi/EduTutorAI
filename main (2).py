# -*- coding: utf-8 -*-
"""Copy of finalgenaifix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Ib51NcHZYgw1rDpdkt15GxhYjHcsaqn
"""

!pip install PyPDF2

!pip install -U bitsandbytes

from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM
import gradio as gr
import torch
import PyPDF2
import re

# Dummy user database for login authentication
# Initialize users_db outside of the main Gradio launch block
# Check if users_db is already defined to prevent resetting on cell re-execution
if 'users_db' not in globals():
    users_db = {"student1": "pass123", "student2": "abc456"}


# Store quiz attempts and classroom tracking
user_sessions = {}

# Step 1: Set device
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Device set to use {device}")

# Step 2: Load model & tokenizer
try:
    model_name = "ibm-granite/granite-3.3-2b-instruct"
    tokenizer = AutoTokenizer.from_pretrained(model_name)
    # Removed load_in_4bit=True to address bitsandbytes error
    model = AutoModelForCausalLM.from_pretrained(model_name)
    generator = pipeline(
        "text-generation",
        model=model,
        tokenizer=tokenizer,
        max_new_tokens=700
    )
    print("‚úÖ Model and tokenizer loaded successfully.")
except Exception as e:
    print(f"‚ùå Error loading model/tokenizer: {e}")
    generator = None

# Utility function to generate text
def generate_response(prompt):
    if generator is None:
        print("‚ùå Error in generate_response: Model not loaded.")
        return "‚ùå Error: Model not loaded."
    try:
        print(f"Generating response for prompt: {prompt[:100]}...")
        response = generator(prompt)
        if response and isinstance(response, list) and len(response) > 0 and "generated_text" in response[0]:
            print("‚úÖ Response generated successfully.")
            return response[0]["generated_text"]
        else:
            print(f"‚ùå Unexpected response format: {response}")
            return "‚ùå Error: Unexpected response format."
    except Exception as e:
        print(f"‚ùå Error during text generation: {e}")
        return f"‚ùå Error during text generation: {e}"

# Functionality 1: Concept Understanding
def concept_understanding(concept):
    prompt = f"""
Explain the concept of '{concept}' in a simple and clear way that a 15-year-old student can easily understand. Include examples and real-world applications if possible.
"""
    return generate_response(prompt)

# Functionality 2: Language Learning
def language_learning(language):
    prompt = f"""
Teach me the basics of {language} language. Include grammar rules, common vocabulary, and parts of speech.
"""
    return generate_response(prompt)

# Functionality 3: Test Generator from PDF
def generate_test_from_pdf(pdf_file):
    if not pdf_file:
        return "‚ùå Please upload a PDF file."
    try:
        reader = PyPDF2.PdfReader(pdf_file)
        text = " ".join([page.extract_text() for page in reader.pages if page.extract_text()])
        if not text:
            return "‚ùå Could not extract text from PDF."
        prompt = f"""
Generate a set of multiple-choice questions from the following content:

{text}

Format each question like this:
Qn: <question>
A. <option A>
B. <option B>
C. <option C>
D. <option D>
Correct Answer: <correct letter>
"""
        return generate_response(prompt)
    except Exception as e:
        return f"‚ùå Failed to process PDF or generate test: {e}"

# Quiz Generation
def quiz_generator(topic):
    prompt = f"Generate a 5-question multiple choice quiz on the topic: {topic}. Format each question with options A, B, C, D and indicate the Correct Answer: <letter>."
    quiz_text = generate_response(prompt)
    print(f"Raw Quiz Generator Output: {quiz_text}") # Add print statement for raw output

    # Parse the generated text into a structured format
    questions = []
    # Updated regex based on observed model output format
    # This pattern looks for a number followed by a period and space, then captures the question and options.
    # It also handles the "Correct Answer: <letter>." part.
    question_pattern = re.compile(r'(\d+)\.\s*(.*?)\n\s*A\.\s*(.*?)\n\s*B\.\s*(.*?)\n\s*C\.\s*(.*?)\n\s*D\.\s*(.*?)\n\s*Correct Answer:\s*([A-D])\.', re.DOTALL)
    matches = question_pattern.findall(quiz_text)

    print(f"Matches found by regex: {matches}") # Debug print

    for match in matches:
        question_num = match[0]
        question_text = match[1].strip()
        options_dict = {
            'A': match[2].strip(),
            'B': match[3].strip(),
            'C': match[4].strip(),
            'D': match[5].strip()
        }
        correct_answer = match[6].strip()

        questions.append({
            "question": question_text,
            "options": options_dict,
            "correct_answer": correct_answer
        })
    print(f"Final Parsed Questions list: {questions}") # Debug print
    return questions


# Auth Logic
def authenticate(username, password):
    return users_db.get(username) == password

def register_user(new_username, new_password):
    if new_username in users_db:
        return "‚ùå Username already exists!"
    else:
        users_db[new_username] = new_password
        return "‚úÖ User registered successfully. You can now login."

# Full App Logic for Concept, Language, and PDF Test
def run_concept_language_pdf(username, concept, language, pdf_file):
    if username not in user_sessions:
        user_sessions[username] = []

    concept_output = concept_understanding(concept)
    language_output = language_learning(language)

    # Generate test from PDF
    test_pdf_output = generate_test_from_pdf(pdf_file) # Keep as raw text output
    print(f"PDF Test Generator Output: {test_pdf_output}") # Add print statement


    # Prepare Gradio outputs - must match the order of outputs in run_btn.click
    outputs = [
        concept_output, # concept_out
        language_output, # language_out
        test_pdf_output # test_out
    ]

    return outputs

# New function for Quiz Generation
def run_quiz_generation(quiz_topic):
    # Generate quiz from topic
    quiz_data = quiz_generator(quiz_topic) # Generate quiz using the new input

    # Format quiz data for display
    formatted_quiz_output = ""
    if quiz_data:
        for i, q in enumerate(quiz_data):
            formatted_quiz_output += f"Q{i+1}: {q['question']}\n"
            for option_key, option_value in q['options'].items():
                formatted_quiz_output += f"{option_key}. {option_value}\n"
            formatted_quiz_output += f"Correct Answer: {q['correct_answer']}\n\n"
    else:
        formatted_quiz_output = "Could not generate quiz."

    print(f"Formatted Quiz Output for Gradio: {formatted_quiz_output}") # Debug print

    return formatted_quiz_output

# Gradio Interface
def login_fn(user, pwd):
    if authenticate(user, pwd):
        return gr.update(visible=True), gr.update(value="Login successful. Welcome!"), user
    else:
        return gr.update(visible=False), gr.update(value="Invalid credentials!"), ""

with gr.Blocks() as interface:
    gr.Markdown("# üë©‚Äçüè´ EduTutor AI: Personalized Learning Platform")

    username_state = gr.State("")
    # Removed quiz_questions_state as topic quiz is removed

    with gr.Tab("Login"):
        login_user = gr.Textbox(label="Username")
        login_pwd = gr.Textbox(label="Password", type="password")
        login_status = gr.Textbox(label="Status")
        login_button = gr.Button("Login")

    with gr.Tab("Register"):
        new_user = gr.Textbox(label="New Username")
        new_pwd = gr.Textbox(label="New Password", type="password")
        register_button = gr.Button("Register")
        registration_status = gr.Textbox(label="Registration Status")
        register_button.click(fn=register_user, inputs=[new_user, new_pwd], outputs=registration_status)


    with gr.Tab("Classroom"):
        with gr.Column(visible=False) as app_ui:
            concept = gr.Textbox(label="Enter Concept (e.g., Generative AI)")
            language = gr.Radio(choices=["English", "Hindi"], label="Choose Language")
            pdf = gr.File(label="Upload PDF")

            run_btn = gr.Button("Run Concept, Language, and PDF Test") # Updated button label

            concept_out = gr.Textbox(label="Concept Explanation", show_copy_button=True)
            language_out = gr.Textbox(label="Language Learning", show_copy_button=True)
            test_out = gr.Textbox(label="Generated Test from PDF", show_copy_button=True) # Keep PDF test output


            run_btn.click(fn=run_concept_language_pdf,
                         inputs=[username_state, concept, language, pdf], # Removed quiz_topic from inputs
                         outputs=[concept_out, language_out, test_out]) # Removed quiz_out from outputs

            gr.Markdown("## Quiz Generation") # Added new section for Quiz
            quiz_topic_input = gr.Textbox(label="Enter Topic for Quiz") # Added new input for quiz topic
            generate_quiz_btn = gr.Button("Generate Quiz") # Added new button for quiz generation
            quiz_output = gr.Textbox(label="Generated Quiz", show_copy_button=True) # Added new output for quiz

            generate_quiz_btn.click(fn=run_quiz_generation,
                                    inputs=[quiz_topic_input],
                                    outputs=[quiz_output])


        login_button.click(fn=login_fn, inputs=[login_user, login_pwd], outputs=[app_ui, login_status, username_state])


interface.launch(debug=True, share=True)